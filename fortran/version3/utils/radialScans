#!/usr/bin/env python

# This script will not work if called directly.
# From the command line, you should call sfincsScan with scanType=4, which in turn calls sfincsScan_4, which in turn calls this script.

# The overall goal of this script is to build a list 'radii' of the radial locations to use for a scan,
# along with lists nHats, THats, dnHatdradius, and dTHatdradius for these radial locations.
# The 'directories' list will also be initialized.  (This list must be initialized
# The values of radii will correspond to the requested inputRadialCoordinate in the input.namelist file.
# The values of radii will be determined in part by the input.namelist !ss parameters Nradius, rN_min, rN_max, etc.
# If (geometryScheme=11 or geometryScheme=12 or (geometryScheme=5 and vmecRadialOption>0)) then the radii will be shifted to match
# the radii available in the magnetic equilibrium file.
# Profiles of density and temperature will be read in from the 'profiles' file.

profilesFilename = 'profiles'

import os, inspect
import numpy
from scipy import interpolate
from scipy.io import netcdf
import matplotlib.pyplot as plt
from math import pi, sqrt

######################################################################################3
# There are 2 main parts to this script:
# 1: Determine the radii to use.
# 2: Determine n, T, and their gradients at these radii.
# 
# We now begin the first of these tasks.
######################################################################################3

def findAvailableRadiiInBC():
    # Parse Joachim Geiger's .bc file format to determine psiAHat, aHat, and the available psiN.
    available_psiN = []
    with open(equilibriumFile, 'r') as f:
        equilibriumFileLines = f.readlines()
    lineNum = 0
    while equilibriumFileLines[lineNum][0:2]=="CC":
        lineNum += 1
    header = equilibriumFileLines[lineNum+1].split()
    psiAHat = float(header[4])/(2*pi)
    aHat = float(header[5])
    print "psiAHat = ",psiAHat
    print "aHat = ",aHat
    for whichLine in range(lineNum+2,len(equilibriumFileLines)):
        if "iota" in equilibriumFileLines[whichLine]:
            available_psiN.append(float(equilibriumFileLines[whichLine+2].split()[0]))
    print "available_psiN:"
    print available_psiN
    return available_psiN

def roundRadii(radii,available_psiN):
    print "Rounding requested radii to match available radii in the magnetic equilibrium file."
    # Both VMEC and .bc formats provide a grid of psiN.
    if inputRadialCoordinate==0:
        # psiHat
        availableRadii = [x*psiAHat for x in available_psiN]
    elif inputRadialCoordinate==1:
        # psiN
        availableRadii = available_psiN
    elif inputRadialCoordinate==2:
        # rHat
        availableRadii = [sqrt(x)*aHat for x in available_psiN]
    elif inputRadialCoordinate==3:
        # rN
        availableRadii = [sqrt(x) for x in available_psiN]
    else:
        print "Invalid inputRadialCoordinate: ",inputRadialCoordinate

    if inputRadialCoordinate != 1:
        print "Available radii for the selected inputRadialCoordinate:"
        print availableRadii
    roundedRadii = []
    for radius in radii:
        errors = [(radius-x)**2 for x in availableRadii]
        roundedRadii.append(availableRadii[errors.index(min(errors))])
    print "Radii before rounding:"
    print radii
    # Eliminate any duplicates:
    radii = sorted(list(set(roundedRadii)))
    print "Radii after rounding:"
    print radii
    return radii
        

geometryScheme = readVariable("geometryScheme","int")
if geometryScheme==5 or geometryScheme==11 or geometryScheme==12:
    pass
else:
    print "Error! For scans over radius, you must use geometryScheme=5, 11, or 12."
    exit(1)

Nradius = readScanVariable("Nradius","int")
inputRadialCoordinate = readVariable("inputRadialCoordinate","int")
inputRadialCoordinateForGradients = readVariable("inputRadialCoordinateForGradients","int")
if inputRadialCoordinateForGradients != inputRadialCoordinate:
    print "Warning: This script will overwrite the requested value of inputRadialCoordinateForGradients to match inputRadialCoordinate."

if inputRadialCoordinate==0:
    radiusName = "psiHat"
elif inputRadialCoordinate==1:
    radiusName = "psiN"
elif inputRadialCoordinate==2:
    radiusName = "rHat"
elif inputRadialCoordinate==3:
    radiusName = "rN"
else:
    print "Error! Invalid inputRadialCoordinate."
    exit(1)

radius_min = readScanVariable(radiusName+"_min","float")
radius_max = readScanVariable(radiusName+"_max","float")
if radius_max <= radius_min:
    print "Error! Minimum requested radius must be < maximum requested radius."
    exit(1)

# Do some basic validation:
if Nradius < 1:
    print "Error! Nradius must be >= 1"
    exit(1)
if inputRadialCoordinate==1 and radius_min<0:
    print "Error! psiN_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==1 and radius_max > 1:
    print "Error! psiN_max must be <= 1."
    exit(1)
elif inputRadialCoordinate==2 and radius_min<0:
    print "Error! rHat_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==3 and radius_min<0:
    print "Error! rN_min must be >= 0."
    exit(1)
elif inputRadialCoordinate==3 and radius_max > 1:
    print "Error! rN_max must be <= 1."
    exit(1)

# First set up a simple uniformly spaced grid.  We may shift these points later.
radii = linspace(radius_min, radius_max, Nradius)

# Next, load the magnetic equilibrium.
# We at least need to determine aHat and psiHat, since these two quantities are
# needed to relate the various definitions of radius.
# We may also need to know the surfaces on which the magnetic equilibrium information
# is available.

equilibriumFile = readVariable("equilibriumFile","string")
equilibriumFile = equilibriumFile[1:-1]

if geometryScheme==11 or geometryScheme==12:
    radii = roundRadii(radii,findAvailableRadiiInBC())

if geometryScheme==5:
    try:
        f = netcdf.netcdf_file(equilibriumFile,'r')
    except:
        print "ERROR! Unable to read VMEC wout equilibrium file."
        print "Presently this script assumes the VMEC file is netCDF format rather than ASCII format,"
        print "so this error may arise if you are using an ASCII wout file."
        raise

    vmec_phi = f.variables['phi'][()]
    # The definition of minor radius is not unique. Presently, SFINCS takes the minor radius aHat to be vmec's Aminor_p:
    aHat = f.variables['Aminor_p'][()]
    f.close()
    psiAHat = vmec_phi[-1]/(2*pi)
    print "vmec-derived aHat: ",aHat
    print "vmec-derived psiAHat: ",psiAHat

    vmecRadialOption = readVariable('vmecRadialOption','int')
    if vmecRadialOption==0:
        # Do not shift radial grid points.
        pass
    elif vmecRadialOption==1:
        # Force use of vmec's half mesh
        dpsi = vmec_phi[1]-vmec_phi[0]
        available_psiN = [(x - dpsi/2)/vmec_phi[-1] for x in vmec_phi[1:]]
        print "available_psiN:"
        print available_psiN
        radii = roundRadii(radii, available_psiN)
    elif vmecRadialOption==2:
        # Force use of vmec's full mesh
        available_psiN = [x / vmec_phi[-1] for x in vmec_phi]
        print "available_psiN:"
        print available_psiN
        radii = roundRadii(radii, available_psiN)
    else:
        print "Error! Invalid vmecRadialOption"


# More validation:
if inputRadialCoordinate==2 and radius_max > aHat:
    print "Error! rHat_max must be <= aHat."
    exit(1)

print "Here are the values of "+radiusName+" we will use for this scan:"
print radii

exit(0)

directories = [radiusName+"_"+str(radius) for radius in radii]

radii_copy = list(radii)
directories_copy = list(directories)

# See if any runs with the same description already exist.
# This happens if you re-run sfincsScan more than once in the same directory.
for i in range(len(radii_copy)):
    directory = directories_copy[i]
    if os.path.exists(directory):
        print "Warning: directory "+directory+" already exists, so skipping this run."
        radii.remove(radii_copy[i])
        directories.remove(directory)

######################################################################################3
# At this point, the radii have been finalized.
# Now move on to the second phase of the problem: determining n and T (and their
# gradients) on these radii.
######################################################################################3


# Determine number of species according to the input.namelist file:
Zs = readVariable('Zs','string')
Zs = Zs.split()
Nspecies = len(Zs)
for i in range(Nspecies):
    Zs[i] = float(Zs[i])
if Nspecies != len(readVariable('mHats','string').split()):
    print "Error! Number of species is not consistent among Zs and mHats in input.namelist."
    exit(1)
print "Number of species determined from the input.namelist file: ",Nspecies

# Read in profile information.
try:
    with open(profilesFilename, 'r') as f:
        profilesFile = f.readlines()
except:
    print "ERROR! Unable to read profiles file."
    raise

profilesScheme = readScanVariable("profilesScheme","int")
if profilesScheme == 1:
    data_radius = []
    data_nHats = []
    data_THats = []
    for i in range(Nspecies):
        data_nHats.append([])
        data_THats.append([])
    for line in profilesFile:
        line = line.strip()
        if line[0] == '!' or line[0] == '#':
            continue
        print line.split()
        if Nspecies*2+1 != len(line.split()):
            print "Error! Each line in the profiles file should have 2*Nspecies+1 values. The following line seems to have the wrong number of values:"
            print line
            exit(1)
        lineSplit = line.split()
        try:
            data_radius.append(float(lineSplit[0]))
            for i in range(Nspecies):
                data_nHats[i].append(float(lineSplit[2*i+1]))
                data_THats[i].append(float(lineSplit[2*i+2]))
        except:
            print "Error parsing the following line of the profiles file:"
            print line
            raise

    print "Here are the radial coordinates read from the profiles file:"
    print data_radius
    for i in range(Nspecies):
        print "Here comes the data for nHat of species "+str(i+1)+" read from the profiles file:"
        print data_nHats[i]
        print "Here comes the data for THat of species "+str(i+1)+" read from the profiles file:"
        print data_THats[i]

    # Interpolate profiles onto the requested points:
    radii_fine = numpy.linspace(min(data_radius), max(data_radius), 100)
    nHats = []
    THats = []
    dnHatdradii = []
    dTHatdradii = []
    nHats_fine = []
    THats_fine = []
    dnHatdradii_fine = []
    dTHatdradii_fine = []
    data_radius_half = []
    for iradius in range (1,len(data_radius)):
        data_radius_half.append((data_radius[iradius-1]+data_radius[iradius])/2)
    dnHatdradii_finiteDifference = []
    dTHatdradii_finiteDifference = []
    for ispecies in range(Nspecies):
        dnHatdradius_finiteDifference = []
        dTHatdradius_finiteDifference = []
        for ir in range(1,len(data_radius)):
            dnHatdradius_finiteDifference.append((data_nHats[ispecies][ir]-data_nHats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
            dTHatdradius_finiteDifference.append((data_THats[ispecies][ir]-data_THats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
        dnHatdradii_finiteDifference.append(dnHatdradius_finiteDifference)
        dTHatdradii_finiteDifference.append(dTHatdradius_finiteDifference)

        # Fit a cubic spline. See http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html
        #interpolator = interpolate.splrep(data_radius, data_nHats[ispecies], s=0)
        interpolator = interpolate.splrep(data_radius, data_nHats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            nHats.append(interpolate.splev(radii,interpolator, der=0))
            dnHatdradii.append(interpolate.splev(radii,interpolator, der=1))
        else:
            nHats.append([])
            dnHatdradii.append([])
        nHats_fine.append(interpolate.splev(radii_fine,interpolator, der=0))
        dnHatdradii_fine.append(interpolate.splev(radii_fine,interpolator, der=1))

        interpolator = interpolate.splrep(data_radius, data_THats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            THats.append(interpolate.splev(radii,interpolator, der=0))
            dTHatdradii.append(interpolate.splev(radii,interpolator, der=1))
        else:
            THats.append([])
            dTHatdradii.append([])
        THats_fine.append(interpolate.splev(radii_fine,interpolator, der=0))
        dTHatdradii_fine.append(interpolate.splev(radii_fine,interpolator, der=1))
        
    # Plot the input profiles and their derivatives:
    fig = plt.figure()
    fig.patch.set_facecolor('white')
    if Nspecies>1:
        numQuantities = 2*(2*Nspecies+2)
    else:
        numQuantities = 4
    numCols = math.ceil(math.sqrt(numQuantities*1.0))
    numRows = math.ceil(numQuantities*1.0/numCols)
    plotNum = 1

    if Nspecies>1:
        # Plot nHat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,nHats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("nHats")
        plotNum += 1
        plt.legend(loc=0, borderaxespad=0., prop={'size':9})

        # Plot dnHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusName+"s")
        plotNum += 1

        # Plot THat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,THats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("THats")
        plotNum += 1

        # Plot dTHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusName+"s")
        plotNum += 1

    # Plot nHat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius,data_nHats[ispecies],'.',label="data")
        plt.plot(radii_fine,nHats_fine[ispecies],'-',label="spline")
        plt.plot(radii, nHats[ispecies],'x',label="requested")
        if ispecies==0:
            plt.legend(loc=0, borderaxespad=0., prop={'size':9})
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("nHat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(nHat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius_half,dnHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label="spline")
        plt.plot(radii, dnHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusName+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot THat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius,data_THats[ispecies],'.',label="data")
        plt.plot(radii_fine,THats_fine[ispecies],'-',label="spline")
        plt.plot(radii, THats[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("THat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(THat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius_half,dTHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label="spline")
        plt.plot(radii, dTHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusName+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    titleString = "Plot generated by "+ inspect.getfile(inspect.currentframe()) + "\nRun in "+os.getcwd()
    ax = fig.add_axes([0,0,1,1], frameon=False)
    ax.text(0.5,0.99,titleString,horizontalalignment='center',verticalalignment='top')
    plt.show(block=False)

elif profilesScheme == 2:
    pass
else:
    print "Error! profilesScheme must be set to 1 or 2."
    exit(1)








print
print "Here are the directories that will be created:"
print directories


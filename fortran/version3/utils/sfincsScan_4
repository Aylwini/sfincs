#!/usr/bin/env python

# This script will not work if called directly.
# From the command line, you should call sfincsScan instead.

profilesFilename = 'profiles'

import os, inspect
import numpy
from scipy import interpolate
import matplotlib.pyplot as plt

print "This is "+ inspect.getfile(inspect.currentframe())
print "Beginning a scan over radius."

geometryScheme = readVariable("geometryScheme","int")
if geometryScheme==5 or geometryScheme==11 or geometryScheme==12:
    pass
else:
    print "Error! For scanType=4, you must use geometryScheme=5, 11, or 12."
    exit(1)

Nradius = readScanVariable("Nradius","int")
inputRadialCoordinate = readVariable("inputRadialCoordinate","int")
inputRadialCoordinateForGradients = readVariable("inputRadialCoordinateForGradients","int")
if inputRadialCoordinateForGradients != inputRadialCoordinate:
    print "Warning: This script will overwrite the request value of inputRadialCoordinateForGradients to match inputRadialCoordinate."

if inputRadialCoordinate==0:
    radiusName = "psiHat"
elif inputRadialCoordinate==1:
    radiusName = "psiN"
elif inputRadialCoordinate==2:
    radiusName = "rHat"
elif inputRadialCoordinate==3:
    radiusName = "rN"
else:
    print "Error! Invalid inputRadialCoordinate."
    exit(1)

radius_min = readScanVariable(radiusName+"_min","float")
radius_max = readScanVariable(radiusName+"_max","float")
if radius_max <= radius_min:
    print "Error! Minimum requested radius must be < maximum requested radius."
    exit(1)

radii = linspace(radius_min, radius_max, Nradius)
print "Here are the values of "+radiusName+" we will use for this scan:"
print radii

# Determine number of species according to the input.namelist file:
Zs = readVariable('Zs','string')
Zs = Zs.split()
Nspecies = len(Zs)
for i in range(Nspecies):
    Zs[i] = float(Zs[i])
if Nspecies != len(readVariable('mHats','string').split()):
    print "Error! Number of species is not consistent among Zs and mHats in input.namelist."
    exit(1)
print "Number of species determined from the input.namelist file: ",Nspecies


directories = [radiusName+"_"+str(radius) for radius in radii]

radii_copy = list(radii)
directories_copy = list(directories)

# See if any runs with the same description already exist.
# This happens if you re-run sfincsScan more than once in the same directory.
for i in range(len(radii_copy)):
    directory = directories_copy[i]
    if os.path.exists(directory):
        print "Warning: directory "+directory+" already exists, so skipping this run."
        radii.remove(radii_copy[i])
        directories.remove(directory)


# Read in profile information.
try:
    with open(profilesFilename, 'r') as f:
        profilesFile = f.readlines()
except:
    print "ERROR! Unable to read profiles file."
    raise

profilesScheme = readScanVariable("profilesScheme","int")
if profilesScheme == 1:
    data_radius = []
    data_nHats = []
    data_THats = []
    for i in range(Nspecies):
        data_nHats.append([])
        data_THats.append([])
    for line in profilesFile:
        line = line.strip()
        if line[0] == '!' or line[0] == '#':
            continue
        print line.split()
        if Nspecies*2+1 != len(line.split()):
            print "Error! Each line in the profiles file should have 2*Nspecies+1 values. The following line seems to have the wrong number of values:"
            print line
            exit(1)
        lineSplit = line.split()
        try:
            data_radius.append(float(lineSplit[0]))
            for i in range(Nspecies):
                data_nHats[i].append(float(lineSplit[2*i+1]))
                data_THats[i].append(float(lineSplit[2*i+2]))
        except:
            print "Error parsing the following line of the profiles file:"
            print line
            raise

    print "Here are the radial coordinates read from the profiles file:"
    print data_radius
    for i in range(Nspecies):
        print "Here comes the data for nHat of species "+str(i+1)+" read from the profiles file:"
        print data_nHats[i]
        print "Here comes the data for THat of species "+str(i+1)+" read from the profiles file:"
        print data_THats[i]

    # Interpolate profiles onto the requested points:
    radii_fine = numpy.linspace(min(data_radius), max(data_radius), 100)
    nHats = []
    THats = []
    dnHatdradii = []
    dTHatdradii = []
    nHats_fine = []
    THats_fine = []
    dnHatdradii_fine = []
    dTHatdradii_fine = []
    data_radius_half = []
    for iradius in range (1,len(data_radius)):
        data_radius_half.append((data_radius[iradius-1]+data_radius[iradius])/2)
    dnHatdradii_finiteDifference = []
    dTHatdradii_finiteDifference = []
    for ispecies in range(Nspecies):
        dnHatdradius_finiteDifference = []
        dTHatdradius_finiteDifference = []
        for ir in range(1,len(data_radius)):
            dnHatdradius_finiteDifference.append((data_nHats[ispecies][ir]-data_nHats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
            dTHatdradius_finiteDifference.append((data_THats[ispecies][ir]-data_THats[ispecies][ir-1]) / (data_radius[ir]-data_radius[ir-1]))
        dnHatdradii_finiteDifference.append(dnHatdradius_finiteDifference)
        dTHatdradii_finiteDifference.append(dTHatdradius_finiteDifference)

        # Fit a cubic spline. See http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html
        #interpolator = interpolate.splrep(data_radius, data_nHats[ispecies], s=0)
        interpolator = interpolate.splrep(data_radius, data_nHats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            nHats.append(interpolate.splev(radii,interpolator, der=0))
            dnHatdradii.append(interpolate.splev(radii,interpolator, der=1))
        else:
            nHats.append([])
            dnHatdradii.append([])
        nHats_fine.append(interpolate.splev(radii_fine,interpolator, der=0))
        dnHatdradii_fine.append(interpolate.splev(radii_fine,interpolator, der=1))

        interpolator = interpolate.splrep(data_radius, data_THats[ispecies])
        if len(radii)>0:
            # The if/else block is here because interpolate.splev fails if new grid is empty.
            THats.append(interpolate.splev(radii,interpolator, der=0))
            dTHatdradii.append(interpolate.splev(radii,interpolator, der=1))
        else:
            THats.append([])
            dTHatdradii.append([])
        THats_fine.append(interpolate.splev(radii_fine,interpolator, der=0))
        dTHatdradii_fine.append(interpolate.splev(radii_fine,interpolator, der=1))
        
    # Plot the input profiles and their derivatives:
    fig = plt.figure()
    fig.patch.set_facecolor('white')
    if Nspecies>1:
        numQuantities = 2*(2*Nspecies+2)
    else:
        numQuantities = 4
    numCols = math.ceil(math.sqrt(numQuantities*1.0))
    numRows = math.ceil(numQuantities*1.0/numCols)
    plotNum = 1

    if Nspecies>1:
        # Plot nHat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,nHats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("nHats")
        plotNum += 1
        plt.legend(loc=0, borderaxespad=0., prop={'size':9})

        # Plot dnHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusName+"s")
        plotNum += 1

        # Plot THat for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,THats_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("THats")
        plotNum += 1

        # Plot dTHatdradius for all species on 1 plot:
        plt.subplot(numRows,numCols,plotNum)
        for ispecies in range(Nspecies):
            plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label="Species "+str(ispecies+1))
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusName+"s")
        plotNum += 1

    # Plot nHat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius,data_nHats[ispecies],'.',label="data")
        plt.plot(radii_fine,nHats_fine[ispecies],'-',label="spline")
        plt.plot(radii, nHats[ispecies],'x',label="requested")
        if ispecies==0:
            plt.legend(loc=0, borderaxespad=0., prop={'size':9})
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("nHat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(nHat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius_half,dnHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dnHatdradii_fine[ispecies],'-',label="spline")
        plt.plot(radii, dnHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dnHatd"+radiusName+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot THat
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius,data_THats[ispecies],'.',label="data")
        plt.plot(radii_fine,THats_fine[ispecies],'-',label="spline")
        plt.plot(radii, THats[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("THat, species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    # Plot d(THat)/d(radius)
    for ispecies in range(Nspecies):
        plt.subplot(numRows,numCols,plotNum)
        plt.plot(data_radius_half,dTHatdradii_finiteDifference[ispecies],'.',label="finite difference")
        plt.plot(radii_fine,dTHatdradii_fine[ispecies],'-',label="spline")
        plt.plot(radii, dTHatdradii[ispecies],'x',label="requested")
        plotNum += 1
        plt.xlabel(radiusName)
        plt.title("dTHatd"+radiusName+", species "+str(ispecies+1)+" (Z="+str(Zs[ispecies])+")")

    titleString = "Plot generated by "+ inspect.getfile(inspect.currentframe()) + "\nRun in "+os.getcwd()
    ax = fig.add_axes([0,0,1,1], frameon=False)
    ax.text(0.5,0.99,titleString,horizontalalignment='center',verticalalignment='top')
    plt.show(block=False)

elif profilesScheme == 2:
    pass
else:
    print "Error! profilesScheme must be set to 1 or 2."
    exit(1)








print
print "Here are the directories that will be created:"
print directories

while True:
    proceed=raw_input("Should I go ahead and launch these "+str(len(radii))+" jobs? [y/n] ")
    if proceed=="y" or proceed=="n":
        break
    print "You must enter either y or n."

if proceed=="n":
    exit(0)
print "launching jobs..."

# Read in the job.sfincsScan file:
with open(jobFilename, 'r') as f:
    jobFile = f.readlines()

for runNum in range(len(radii)):
    directory = directories[runNum]
    print "Beginning to handle job "+str(runNum+1)+" of "+str(len(radii))+": "+directory

    # To be extra safe, check again to see if the directory exists.
    if os.path.exists(directory):
        print "Warning: directory "+directory+" already exists."
        i = -1
        while True:
            i += 1
            directory2 = directory+"_"+str(i)
            if not os.path.exists(directory2):
                break
        directory = directory2
    os.makedirs(directory)
    os.chdir(directory)

    # Copy the job.sfincsScan file:
    thisJobFile = list(jobFile)
    # This next function is defined separately for each system in sfincsScan
    nameJobFile(thisJobFile,directory)
    f = open(jobFilename,"w")
    f.writelines(thisJobFile)
    f.close()

    # Now copy the input.namelist file:
    f = open(filename,"w")
    for line in inputFile:
        if namelistLineContains(line,radiusName+"_wish"):
            line = "  "+radiusName+"_wish = "+str(radii[runNum])+" ! Set by sfincsScan.\n"

        if namelistLineContains(line,"inputRadialCoordinateForGradients"):
            line = "  inputRadialCoordinateForGradients = "+str(inputRadialCoordinate)+" ! Set by sfincsScan.\n"

        if namelistLineContains(line,"nHats"):
            line = "  nHats ="
            for ispecies in range(Nspecies):
                line += " "+str(nHats[ispecies][runNum])
            line += " ! Set by sfincsScan.\n"

        if namelistLineContains(line,"dnHatd"+radiusName+"s"):
            line = "  dnHatd"+radiusName+"s ="
            for ispecies in range(Nspecies):
                line += " "+str(dnHatdradii[ispecies][runNum])
            line += " ! Set by sfincsScan.\n"

        if namelistLineContains(line,"THats"):
            line = "  THats ="
            for ispecies in range(Nspecies):
                line += " "+str(THats[ispecies][runNum])
            line += " ! Set by sfincsScan.\n"

        if namelistLineContains(line,"dTHatd"+radiusName+"s"):
            line = "  dTHatd"+radiusName+"s ="
            for ispecies in range(Nspecies):
                line += " "+str(dTHatdradii[ispecies][runNum])
            line += " ! Set by sfincsScan.\n"

        f.write(line)
    f.close()

    # Submit the sfincs job:
    try:
        # We need to include .split(" ") to separate the command-line arguments into an array of strings.   
        # I'm not sure why python requires this. 
        submissionResult = subprocess.call(submitCommand.split(" "))
        #submissionResult=0
    except:
        print "ERROR! Unable to submit run "+directory+" for some reason."
        raise
    else:
        if submissionResult==0:
            print "No errors submitting job "+directory
        else:
            print "Nonzero exit code returned when trying to submit job "+directory

    os.chdir("..")

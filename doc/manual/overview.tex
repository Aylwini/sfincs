\chapter{Overview}


The \sfincs~code is a freely available, open-source tool for solving neoclassical-type kinetic problems in nonaxisymmetric or axisymmetric plasmas
with nested toroidal flux surfaces.
The code solves a drift-kinetic equation for an arbitrary number of species.  Optionally, a quasi-neutrality
equation can also be solved to obtain the self-consistent variation of the electrostatic potential on a flux surface.

This manual describes ``version 3'' of \sfincs.  There are two older versions of the
code called singleSpecies and multiSpecies.

This document discusses the practical use and operation of the code.  For more details about the specific equations implemented,
see the version 3 technical documentation available in the \path{sfincs/docs} directory.
Ref \cite{sfincsPaper} gives many details and some early physics results.

Often, the limiting factor for \sfincs~is the ability of \mumps~or \superludist~to factorize the preconditioner matrix.
You may therefore find it useful to see the control parameters and error codes in the \mumps~user manual:
\url{http://mumps.enseeiht.fr/doc/userguide_5.0.0.pdf}.


\section{Geometry options}
In \sfincs, a variety of options are available for the magnetic field geometry.  The geometry can be read directly
from a {\ttfamily vmec wout}
file, or from the {\ttfamily .bc} format Boozer-coordinate data files used at the Max Planck Institute for Plasma Physics (IPP).
A general analytic model for the magnetic field is also available, given by equation (\ref{eq:Bmodel}),
as are several analytic models for LHD and W7-X in which 3 or 4 Fourier components are retained.
For more details about geometry options in \sfincs, see section \ref{sec:geometryParameters}.

\section{GMRES/KSP and preconditioning}
\label{sec:gmres}

At its heart, \sfincs~solves one or more large sparse linear systems $Ax=b$.  Here $b$ is a known right-hand side vector,
$A$ is a large (often millions $\times$ millions) known sparse matrix, and $x$ is the desired and unknown solution vector.
The direct way to solve such systems is to $LU$-factorize
the matrix $A$ into lower- and upper-triangular factors.
Once the $L$ and $U$ factors are found, the solution of the linear system
for any right-hand side vector can be rapidly obtained.  However, even if the original matrix is sparse, the $L$ and $U$ factors
are generally not sparse, and so a very large amount of memory can be required for a direct $LU$-factorization.

An alternative way to solve
such large linear systems is with a so-called ``Krylov-space'' iterative method, which can dramatically reduce the memory required
compared to a direct solution.  For the non-symmetric matrices that arise in \sfincs, the preferred Krylov-space
algorithm is called GMRES (Generalized Minimal RESidual.)  In \sfincs, the \PETSc~library is used to solve the large systems
of equations. \PETSc~calls its family of linear solvers KSP, so in the output of \sfincs~you will see a ``KSP residual'' reported
as GMRES iterates towards the solution.

An important element of Krylov methods is preconditioning.  The art of preconditioning is to find a linear operator which has similar eigenvalues
to the ``true'' matrix you would like to invert (or more precisely, to $LU$-factorize), but which can be inverted faster.
If a good preconditioner can be found, the number of GMRES iterations is greatly reduced.  Many schemes for preconditioning exist,
but the version adopted in \sfincs~is to explicity form and $LU$-factorize a preconditioning matrix which is similar
to the true matrix (but somewhat simpler).  There is a basic trade-off:
the more similar the preconditioner matrix is to the true matrix, the fewer iterations will be required, but the more time will
be required to $LU$-factorize the preconditioning operator.  The usual preconditioner matrix in \sfincs~is obtained by dropping all coupling
between grid points in the speed coordinate and dropping coupling between species.  The preconditioner matrix need not be a physically
accurate or meaningful operator; as long as GMRES converges, the solution obtained will be independent of the preconditioner to whatever tolerance is specified.

\section{\sfincs~vs. \sfincsScan}
The core fortran part of \sfincs~solves the kinetic equation for each species
at a single flux surface, a single value of $E_r$, and a single set of other parameters.
However, often the goal is to determine the ambipolar $E_r$ at one or more surfaces, or to scan some other parameter.
For this task, the \sfincsScan~family of \python~scripts is available.
For a full list of the types of scans available, see section \ref{sec:sfincsScanParams}

\section{Input and Output}

The input parameters for a \sfincs~computation are specified in a file named {\ttfamily input.namelist}.
This file contains both information for the fortran part of \sfincs~(in standard fortran namelist format),
as well as special lines beginning with {\ttfamily !ss} which are read by \sfincsScan.
The variables which can be specified in {\ttfamily input.namelist} are detailed in chapter \ref{ch:input}.
For scans over minor radius, an additional file named {\ttfamily profiles} is used to specify the profiles of density and temperature
for each species, as well as the range of radial electric field to consider.

The output from a single \sfincs~computation is saved in \HDF~format in the file {\ttfamily sfincsOutput.h5}.
To browse this file you can enter {\ttfamily h5dump sfincsOutput.h5|less} from the command line.
Every array saved in this file is annotated with strings that describe the array dimensions,
for example \Ntheta$\times$ \Nzeta. One of the array dimensions may be {\ttfamily iteration},
which can either indicate the iteration of the Newton solver for a nonlinear calculation,
or which right-hand side vector was used when computing a transport matrix.
Many of the variables in the output file are also annotated with
text that describes their meaning and normalization.

\section{Questions, Bugs, and Feedback}

To report any bugs, provide feedback, or ask questions, contact Matt Landreman at
\href{mailto:matt.landreman@gmail.com}{\nolinkurl{matt.landreman@gmail.com} }

%\begin{figure}[htbp]
%\begin{center}
%%\includegraphics[width=1.0\textwidth]{poloidal_cross-sections.pdf}
%\mycaption{Trajectories of trapped particles.  (a) In tokamaks and omnigenous stellarators,
%all collisionless trajectories are confined.  (b) In contrast, trapped particles in other stellarators
%may have a radial drift that does not average to zero.
%\label{fig:poloidal_cross_sections}}
%\end{center}
%\end{figure}





